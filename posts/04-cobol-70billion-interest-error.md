# COBOL 40년 이자계산 오류를 발견한 이야기 — 70억원 소급 보정

> COBOL → Spring Batch 마이그레이션 중 건당 1원의 차이를 추적했더니, 40년간 누적된 70억원 규모의 구조적 오류였다.

---

## 들어가며

2023년, 한전KDN 영업배전 차세대 4.0 프로젝트에 PL로 참여했다. 미션은 명확했다. **COBOL 기반 전기요금 정산 배치를 Spring Batch로 전환**하는 것.

월 175만 건, 피크 일 20~30만 건의 전기요금 정산을 처리하는 시스템이었다. 40년 넘게 COBOL로 돌아가고 있었고, 아무도 이 코드에 문제가 있다고 생각하지 않았다.

나도 그랬다. 마이그레이션이 목표였지, 오류를 찾으러 간 게 아니었으니까.

---

## 1원의 차이

Spring Batch로 전환한 정산 로직의 검증 단계에서, COBOL 원본과 Java 결과를 건건이 대조하고 있었다. 대부분은 일치했다. 그런데 일부 건에서 **1원**씩 차이가 났다.

처음에는 당연히 내 코드를 의심했다. Spring Batch 쪽 반올림 로직을 몇 번이고 다시 확인했다. 하지만 내 코드는 **전기공급약관**에 명시된 이자 계산 기준을 그대로 구현한 것이었다.

그래서 방향을 바꿨다. **"내 코드가 틀린 게 아니라, COBOL이 틀린 건 아닐까?"**

---

## 전기공급약관 vs COBOL 라운딩

전기공급약관에는 이자 계산 시 반올림 처리 기준이 명확하게 규정되어 있다. 하지만 COBOL 소스를 열어보니, 내부 라운딩 로직이 **약관 규정과 일치하지 않았다**.

단순한 버그가 아니었다. COBOL의 고유한 연산 특성에서 비롯된 **구조적 편차(systematic bias)** 였다.

### 핵심: COBOL의 라운딩 특성

COBOL은 고정소수점(fixed-point) 연산을 기본으로 사용한다. `COMPUTE` 구문에서의 중간값 처리, `ROUNDED` 구의 적용 범위, 그리고 `PICTURE` 절의 소수 자릿수 정의에 따라 라운딩 동작이 달라진다.

```cobol
* COBOL 정산 로직 (개념적 재현)
COMPUTE WS-INTEREST = WS-AMOUNT * WS-RATE / 365
    ROUNDED.
COMPUTE WS-RESULT = WS-PRINCIPAL + WS-INTEREST.
```

문제는 **중간 계산 단계에서의 라운딩 시점**이었다. 약관은 최종 결과에 대한 라운딩을 규정하고 있었지만, COBOL 로직은 중간 연산 과정에서 이미 한 번 라운딩이 적용되고 있었다. 이 미세한 차이가 **방향성 있는 편차(directional bias)** 를 만들었다.

```java
// Spring Batch — 약관 기준 정확한 구현
BigDecimal interest = amount
    .multiply(rate)
    .divide(BigDecimal.valueOf(365), 10, RoundingMode.HALF_UP);

BigDecimal result = principal.add(interest)
    .setScale(0, RoundingMode.HALF_UP);  // 최종 결과에서만 반올림
```

Java의 `BigDecimal`은 정밀도를 명시적으로 제어할 수 있다. 중간 계산에서 충분한 소수 자릿수를 유지하고, **최종 결과에서만 약관 기준대로 반올림**하면 정확한 값이 나온다.

COBOL은 `PICTURE` 절에서 소수 자릿수가 고정되기 때문에, 중간 계산에서 의도치 않은 절사/반올림이 발생할 수 있다. 이것이 40년간 잠복한 원인이었다.

---

## 건당 1원, 40년이면 70억

1원.

한 건의 정산에서 보면 아무것도 아닌 차이다. 하지만 이 오류는 **모든 이자 계산 건에 일관되게 적용**되는 구조적 문제였다. 랜덤 오류가 아니라 **체계적 편차**였기 때문에, 시간이 지날수록 한 방향으로 누적됐다.

```
건당 평균 편차: ~1원
월 처리 건수: ~175만 건
연간 처리: ~2,100만 건
40년 누적: ~8.4억 건

단순 계산으로도 수십억 원.
실제 운영 데이터 기반 산출 결과: 약 70억원.
```

---

## 증명

"COBOL에 오류가 있습니다"라고 말하는 것은 쉽다. 40년간 운영해온 시스템에 대해 그런 주장을 하려면, **운영 데이터로 증명**해야 한다.

나는 다음 과정을 거쳤다.

### 1단계: 1:1 대조 분석

COBOL 소스의 라운딩 로직과 전기공급약관의 이자 계산 기준을 라인 단위로 대조했다. 어디서 약관 규정과 어긋나는지를 정확히 특정했다.

### 2단계: 운영 데이터 기반 규모 산출

실제 고객 정산 이력 데이터를 기반으로, COBOL 결과값과 약관 기준 정확한 값의 차이를 전수 검증했다. 단순 샘플링이 아니라, 가용한 이력 데이터 전체를 대상으로 산출했다.

### 3단계: 합동 시연회

한전과 KDN 합동 시연회에서 운영 데이터를 기반으로 직접 시연했다. 특정 고객의 정산 이력을 추적하면서 COBOL 결과와 약관 기준 결과의 차이를 건건이 보여줬다.

결과: **소급 보정 결정**.

---

## 왜 40년간 발견되지 않았을까

이 부분이 가장 많이 받는 질문이다. 몇 가지 이유가 있다.

**1. 건당 차이가 너무 작았다**

1원. 어떤 검증 절차에서도 이 정도 차이는 허용 오차 범위로 취급된다. 누군가 의도적으로 COBOL 라운딩 로직과 약관 규정을 1:1 대조하지 않는 한, 발견될 수 없었다.

**2. 레거시 코드에 대한 신뢰**

"40년간 잘 돌아간 코드"라는 사실 자체가 강력한 신뢰를 만든다. 아무도 의심하지 않았다. 코드 자체에 문법적 오류가 있는 것도 아니었으니까.

**3. 마이그레이션이라는 특수한 상황**

언어를 전환하면서 결과를 건건이 대조하는 상황은, 시스템의 전체 수명 중 거의 발생하지 않는다. **전환 프로젝트가 아니었다면 앞으로도 발견되지 않았을 것**이다.

---

## 교훈: 코드 정합성 vs 비즈니스 정합성

개발자는 보통 **코드의 정합성**을 검증한다. 문법이 맞는지, 테스트가 통과하는지, 기존 코드와 결과가 일치하는지.

하지만 이 경험으로 배운 것은, **비즈니스 규정과의 정합성**이 더 중요할 수 있다는 것이다.

기존 COBOL 코드는 문법적으로 완벽했다. 40년간 에러 없이 동작했다. 하지만 **약관이라는 비즈니스 규정을 위반**하고 있었다. 코드가 맞는지가 아니라, **코드가 구현해야 하는 규칙이 맞는지**를 검증해야 했다.

```
코드 정합성:  "이 코드가 기존 코드와 같은 결과를 내는가?"  → PASS
비즈니스 정합성: "이 코드가 약관 규정대로 계산하는가?"    → FAIL (40년간)
```

마이그레이션 프로젝트에서 "기존과 동일한 결과"를 목표로 했다면, 이 오류는 그대로 새 시스템으로 이식됐을 것이다. **"기존 코드를 복제하는 것"과 "비즈니스 요구사항을 정확히 구현하는 것"은 다르다.**

---

## Spring Batch로의 전환

오류를 발견하고 끝이 아니었다. 약관 기준에 맞는 정확한 이자 계산 로직을 Spring Batch로 구현하는 것이 본래의 미션이었다.

### 성능 최적화 3축

| 축 | 적용 기술 | 효과 |
|----|-----------|------|
| Chunk 최적화 | 1,000건 Chunk + 8스레드 병렬 | 단위 처리량 극대화 |
| 파티셔닝 | 6개 지역본부 기준 데이터 분할 | 병렬 처리 |
| Flow 병렬화 | 독립 Step 동시 실행 | 전체 시간 단축 |

결과: **3~4시간 → 40~50분 (80%+ 단축)**

카카오페이, 네이버페이 PG 연동과 농어촌융자금 연동 정산 배치까지 포함해서, 월 175만 건을 안정적으로 처리하는 시스템을 완성했다.

---

## 마치며

나는 오류를 찾으러 간 게 아니었다. 마이그레이션을 하러 갔다. 하지만 Spring Batch 코드와 COBOL 코드의 결과를 대조하는 과정에서, **1원의 차이를 무시하지 않았던 것**이 70억원 규모의 구조적 오류를 발견하게 했다.

레거시 마이그레이션을 하는 개발자들에게 한 가지만 말하고 싶다.

> **"기존 코드와 같은 결과"가 목표가 되면 안 된다. "비즈니스 규정에 맞는 결과"가 목표가 되어야 한다.**

40년간 잘 돌아간 코드라도, 처음부터 틀렸을 수 있다.

---

*이 글에 사용된 코드는 실제 운영 코드가 아닌 개념적 재현입니다.*

---

**태그**: `COBOL` `Spring Batch` `레거시 마이그레이션` `금융 정산` `한전` `Java` `BigDecimal` `반올림` `전기요금`
